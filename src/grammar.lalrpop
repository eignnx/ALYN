use std::str::FromStr;
use internment::Intern;
use crate::{
    ast::{RVal, LVal, Binop, Unop, Stmt, SubrDefn, Module, MakeAnn, Span, Ann, Param},
    ty::Ty,
};

grammar(filename: &str);

match {
    r"\s*" => { }, // The default whitespace skipping is disabled if an `ignore pattern` is specified
    r"//[^\n\r]*[\n\r]*" => { }, // Skip `// comments`
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { },  // Skip `/* comments */`
} else {
    _
}

Spanned<T>: Ann<T> = <start: @L> <t: T> <end: @R> => t.with_span(start..end);

BinopExpr<Lhs, Op, Rhs>: RVal = {
    <lhs: Spanned<Lhs>> <op: Op> <rhs: Spanned<Rhs>> => {
        RVal::Binop(op, Box::new(lhs), Box::new(rhs))
    },
};

RAssocBinopClass<Op, Lower>: RVal = {
    BinopExpr<Lower, Op, RAssocBinopClass<Op, Lower>>,
    Lower,
};

pub RVal:  RVal = RAssocBinopClass<      Relop,  RelopRVal>;
RelopRVal: RVal = RAssocBinopClass<  TermBinop,   TermRVal>;
TermRVal:  RVal = RAssocBinopClass<FactorBinop, FactorRVal>;

FactorRVal: RVal = {
    "&" <lval:Spanned<LVal>> => {
        RVal::AddrOf(Box::new(lval))
    },

    <unop: Unop> <rval:Spanned<RValAtom>> => {
        RVal::Unop(unop, Box::new(rval))
    },

    RValAtom,
};

RValAtom: RVal = {
    <digits:r"[0-9]+b"> => RVal::Byte(u8::from_str(&digits[0..digits.len()-1]).unwrap()),
    <digits:r"[0-9]+"> => RVal::Nat(u64::from_str(digits).unwrap()),
    <digits:r"[-+][0-9]+"> => RVal::Int(i64::from_str(digits).unwrap()),

     "bitcast" "{" <ty: Spanned<Ty>> "}" "(" <rval: Spanned<RVal>> ")" => {
        RVal::BitCast(Box::new(ty), Box::new(rval))
    },


    Spanned<LVal> => RVal::LVal(<>),

    <subr_name: NameOParen> <args: CommaListCParen<Spanned<RVal>>> => {
        RVal::Call(subr_name, args)
    },

    "(" <RVal> ")" => <>,
};

LVal: LVal = {
    "*" <rval: Spanned<RValAtom>> => LVal::Deref(Box::new(rval)),
    <ident: Name> => LVal::Var(ident, None),
};

Relop: Binop = {
    "==" => Binop::Eq,
    "!=" => Binop::Ne,
    "<" => Binop::Lt,
    ">" => Binop::Gt,
    "<=" => Binop::Lte,
    ">=" => Binop::Gte,
};

TermBinop: Binop = {
    "+" => Binop::Add,
    "-" => Binop::Sub,
};

FactorBinop: Binop = {
    "&" => Binop::And,
    "|" => Binop::Or,
    ">>" => Binop::Shr,
};

Unop: Unop = {
    "-" => Unop::Neg,
};

pub Stmt: Stmt = {
    <rval: Spanned<RVal>> ";" => Stmt::RVal(rval),

    "let" <var_name: Name> "=" <rhs: Spanned<RVal>> ";" => {
        Stmt::Let(var_name, rhs)
    },

    <lhs: Spanned<LVal>> "=" <rhs: Spanned<RVal>> ";" => Stmt::Assign(lhs, rhs),

    "ret" <rval_opt: Spanned<RVal>?> ";" => Stmt::Ret(rval_opt),

    "while" <cond: Spanned<RVal>> "{" <body: Stmts> "}" => Stmt::While(cond, body),

    "if" <cond: Spanned<RVal>> "{" <true_body: Stmts> "}" <false_body: ("else" "{" <Stmts> "}")?> => {
        Stmt::If(cond, true_body, false_body)
    },
};

Stmts: Vec<Ann<Stmt>> = <stmts: Spanned<Stmt>*> => stmts;

Name: Intern<String> = <r"[a-z][a-z0-9_]*"> => Intern::from_ref(<>);

NameOParen: Intern<String> = <name: r"[a-z][a-z0-9_]*\("> => Intern::from_ref(
    &name[0..name.len()-1]
);

CommaListCParen<P>: Vec<P> = {
    ")" => Vec::new(),

    <first: P> <rest: ("," <P>)*> ","? ")" => {
        std::iter::once(first)
            .chain(rest.into_iter())
            .collect()
    },
};

pub SubrDefn: SubrDefn = {
    "subr"
    <name: NameOParen>
    <params: CommaListCParen<Spanned<Param>>>
    <ret_ty: Ty?>
    "{" <body: Stmts> "}" => SubrDefn {
        name,
        params,
        ret_ty: ret_ty.unwrap_or(Ty::Void),
        body,
    },
};

Ty: Ty = {
    "void" => Ty::Void,
    "bool" => Ty::Bool,
    "byte" => Ty::Byte,
    "int" => Ty::Int,
    "nat" => Ty::Nat,
    "*" <inner: Ty> => Ty::Ptr(Box::new(inner)),
    "subr" "(" <param_tys: CommaListCParen<Ty>> <ret: ("->" <Ty>)?> => {
        Ty::Subr(param_tys, Box::new(ret.unwrap_or(Ty::Void)))
    },
};

Param: Param = {
    <name: Name> ":" <ty: Ty> => Param { name, ty },
};

pub Module: Module = <items: Spanned<Item>*> => Module {
    filename: filename.to_string(),
    decls: items,
};

Item: SubrDefn = { SubrDefn };
