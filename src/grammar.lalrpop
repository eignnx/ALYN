use std::str::FromStr;
use internment::Intern;
use crate::{
    ast::{RVal, LVal, Binop, Unop, Stmt, SubrDecl, Module, MakeAnn, Span, Ann, Param},
    ty::Ty,
};

grammar(filename: &str);

Spanned<T>: Ann<T> = <start: @L> <t: T> <end: @R> => t.with_span(start..end);

AtomicRVal: RVal = {
    #[precedence(level="0")]
    <digits:r"[0-9]+b"> => RVal::Byte(u8::from_str(&digits[0..digits.len()-1]).unwrap()),
    #[precedence(level="0")]
    <digits:r"[0-9]+"> => RVal::Nat(u64::from_str(digits).unwrap()),
    #[precedence(level="0")]
    <digits:r"[-+][0-9]+"> => RVal::Int(i64::from_str(digits).unwrap()),

    #[precedence(level="1")]
    Spanned<LVal> => RVal::LVal(<>),


    <subr_name: r"[a-z][a-z0-9_]*\("> ")" => RVal::Call(Intern::from_ref(&subr_name[0..subr_name.len()-1]), vec![]),
    <subr_name: r"[a-z][a-z0-9_]*\("> <first: Spanned<RVal>> <rest: ("," <Spanned<RVal>>)*> ","? ")" => {
        let args = std::iter::once(first)
            .chain(rest.into_iter())
            .collect();
        RVal::Call(Intern::from_ref(&subr_name[0..subr_name.len()-1]), args)
    },

    "(" <RVal> ")" => <>,
};

pub RVal: RVal = {
    #[precedence(level="0")]
    AtomicRVal => <>,

    #[precedence(level="1")]
    "&" <lval:Spanned<LVal>> => {
        RVal::AddrOf(Box::new(lval))
    },

    #[precedence(level="2")]
    #[assoc(side="left")]
    <start: @L> <lhs:Spanned<AtomicRVal>> <follows: (Binop Spanned<AtomicRVal> @R)+> => {
        let mut acc: Ann<RVal> = lhs;
        for (op, rhs, end) in follows {
            acc = RVal::Binop(op, Box::new(acc), Box::new(rhs)).with_span(start..end);
        }
        acc.value
    },
};

LVal: LVal = {
    r"\*" <rval: Spanned<AtomicRVal>> => LVal::Deref(Box::new(rval)),
    <ident: Name> => LVal::Var(ident, None),
};

Binop: Binop = {
    r"\+" => Binop::Add,
    r"-" => Binop::Sub,
    r"==" => Binop::Eq,
    r"!=" => Binop::Ne,
    r"<" => Binop::Lt,
    r">" => Binop::Gt,
    r"<=" => Binop::Lte,
    r">=" => Binop::Gte,
};

Unop: Unop = {
    r"-" => Unop::Neg,
};

pub Stmt: Stmt = {
    <rval: Spanned<RVal>> ";" => Stmt::RVal(rval),

    "let" <var_name: Name> "=" <rhs: Spanned<RVal>> ";" => {
        Stmt::Let(var_name, rhs)
    },

    <lhs: Spanned<LVal>> "=" <rhs: Spanned<RVal>> ";" => Stmt::Assign(lhs, rhs),

    "ret" <rval_opt: Spanned<RVal>?> ";" => Stmt::Ret(rval_opt),

    "while" <cond: Spanned<RVal>> "{" <body: Stmts> "}" => Stmt::While(cond, body),

    "if" <cond: Spanned<RVal>> "{" <true_body: Stmts> "}" <false_body: ("else" "{" <Stmts> "}")?> => {
        Stmt::If(cond, true_body, false_body)
    },
};

Stmts: Vec<Ann<Stmt>> = <stmts: Spanned<Stmt>*> => stmts;

Name: Intern<String> = <r"[a-z][a-z0-9_]*"> => Intern::from_ref(<>);
NameOParen: Intern<String> = <name: r"[a-z][a-z0-9_]*\("> => Intern::from_ref(
    &name[0..name.len()-1]
);

pub SubrDecl: SubrDecl = {
    "subr" <name: NameOParen> ")" <ret_ty: Ty?> "{" <body: Stmts> "}" => SubrDecl {
        name,
        params: vec![],
        ret_ty: ret_ty.unwrap_or(Ty::Void),
        body,
    },
    "subr" <name: NameOParen>
        <param_first: Spanned<Param>> <param_rest: ("," <Spanned<Param>>)*> ","?
    ")" <ret_ty: Ty?> "{" <body: Stmts> "}" => {
        SubrDecl {
            name,
            params: std::iter::once(param_first).chain(param_rest.into_iter()).collect(),
            ret_ty: ret_ty.unwrap_or(Ty::Void),
            body,
        }
    },
};

Ty: Ty = {
    "void" => Ty::Void,
    "bool" => Ty::Bool,
    "byte" => Ty::Byte,
    "int" => Ty::Int,
    "nat" => Ty::Nat,
    r"\*" <inner: Ty> => Ty::Ptr(Box::new(inner)),
    "subr" "(" ")" <ret: ("->" <Ty>)?> => {
        Ty::Subr(vec![], Box::new(ret.unwrap_or(Ty::Void)))
    },
    "subr" "(" <first: Ty> <rest: ("," <Ty>)*> ")" <ret: ("->" <Ty>)?> => {
        Ty::Subr(vec![], Box::new(ret.unwrap_or(Ty::Void)))
    },
};

Param: Param = {
    <name: Name> ":" <ty: Ty> => Param { name, ty },
};

pub Module: Module = <items: Spanned<Item>*> => Module {
    filename: filename.to_string(),
    decls: items,
};

Item: SubrDecl = { SubrDecl };
